<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Official Spotify full installers</title>
  <link type="image/png" rel="icon" href="favicon.png">
  <link rel="preconnect" href="https://upgrade.scdn.co" crossorigin>
  <link rel="preconnect" href="https://broad-pine-bbc0.amd64fox1.workers.dev" crossorigin>
  <link rel="preload" href="fonts/SpotifyMixUI-Regular.woff2" as="font"
    type="font/woff2" crossorigin="anonymous" />
  <link rel="preload" href="fonts/SpotifyMixUI-Bold.woff2" as="font"
    type="font/woff2" crossorigin="anonymous" />

  <style>
    html {
      /* Всегда показывать вертикальную полосу прокрутки, для более плавного переключения вкладок таблицы */
      overflow-y: scroll;

      /* Стили для адаптации scrollbar под тёмную тему для Firefox */
      scrollbar-color: #666 #2a2a2a;
      scrollbar-width: auto;
    }

    @font-face {
      font-family: 'Spotify UI';
      src: url('fonts/SpotifyMixUI-Regular.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Spotify UI';
      src: url('fonts/SpotifyMixUI-Bold.woff2') format('woff2');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Spotify UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background: #181a1b;
      color: #a59d92;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    .nav-container {
      background: #000000;
      padding: 2rem 2rem;
      margin-bottom: 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      justify-content: center;
    }

    .navbar {
      width: 90%;
      max-width: 1000px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .nav-brand {
      display: flex;
      align-items: center;
      gap: 5px;
      color: #e8e6e3;
      position: absolute;
      left: 0;
      pointer-events: none;
    }

    .nav-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .nav-center a {
      color: #e8e6e3;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      transition: all 0.3s ease;
      font-weight: 700;
    }

    .nav-center a.active {
      background: #1db954;
      color: #000;
    }

    .nav-center a:hover:not(.active) {
      color: #1db954;
    }

    header {
      padding: 20px;
      text-align: center;
    }

    header h1 {
      font-size: 2rem;
      margin-bottom: 20px;
      color: #e8e6e3;
      font-weight: 400;
    }

    header p {
      font-size: 1.2rem;
      color: #ccc;
    }

    .container {
      width: 90%;
      max-width: 1000px;
      margin: 40px auto;
      position: relative;
      overflow-x: auto;
    }

    table.version-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 600px;
      table-layout: fixed;
    }

    /* стиль для разделения версий */
    table.version-table tr:has(.version-cell) {
      border-top: 2px solid #444;
    }

    /* для первой строки убираем верхнюю границу */
    table.version-table tbody tr:first-child {
      border-top: none;
      border-top: 2px solid #444;
    }

    /* стиль для нижней границы последней версии */
    table.version-table tbody tr:last-child {
      border-bottom: 2px solid #444;
    }

    table.version-table thead th {

      text-align: left;
      padding: 8px;
      border-bottom: 1px solid #444;
      font-weight: 700;
    }

    table.version-table tbody td {
      padding: 7px;
      border-bottom: 1px solid #333;
      vertical-align: middle;
      font-size: 14px
    }

    .version-cell {
      font-weight: 500;
      color: #b3b3b3;
      position: relative;
      cursor: default;
    }

    .version-text {
      cursor: default;
      display: inline-block;
      flex-wrap: wrap;
      align-items: flex-start;
      position: relative;
    }

    .short-version {
      font-size: 1.2em;
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      margin-bottom: 4px;
      user-select: none;
      cursor: pointer;
      position: relative;
      z-index: 1;
    }

    .short-version:hover {
      color: #fff;
    }

    .full-version {
      font-size: 0.9em;
      color: #777;
      display: block;
      user-select: none;
      cursor: pointer;
    }

    .full-version:hover {
      color: #aaa;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #a59d92;
      text-decoration: none;
      font-weight: 500;
      background: #ffffff08;
      padding: 6px 10px;
      border-radius: 4px;
      transition: background 0.2s;
      position: relative;
      cursor: pointer;
    }

    .download-link:hover {
      background: #ffffff12;
    }

    .download-icon {
      width: 16px;
      height: 16px;
      fill: currentColor;
      transition: fill 0.2s;
      position: relative;
    }

    .download-link:hover .download-icon {
      fill: #1db954;
    }

    .toast-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #464746;
      color: #b3b3b3;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 500;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .toast-notification.show {
      opacity: 1;
    }

    .action-cell {
      text-align: center;
    }

    .filter-buttons {
      display: flex;
      gap: 10px;
      padding: 8px;
    }

    table.version-table thead td {
      border: none;
      padding: 0;
    }

    table.version-table .filter-button {
      padding: 6px 20px;
      border: 1px solid #474747;
      background: transparent;
      color: #a6a7a7;
      border-radius: 20px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 700;
      transition: all 0.3s ease;
      height: 34px;
    }

    table.version-table .filter-button.active {
      background: #1db954;
      color: #000;
      pointer-events: none;
      border: 1px solid #ffffff00;
    }

    table.version-table .filter-button:hover:not(.active) {
      background: #d6d6d62a;
    }

    #versions-container {
      transition: opacity 0.3s ease-in-out;
    }

    .linux-repo-wrapper {
      background: #242628;
      border-radius: 8px;
      overflow: hidden;
    }

    .repo-header {
      display: grid;
      grid-template-columns: 1fr 100px 150px;
      gap: 16px;
      padding: 12px 16px;
      background: #2a2e2f;
      border-bottom: 1px solid #333;
      font-weight: 700;
      color: #e8e6e3;
    }

    .repo-content {
      height: 170px;
      overflow-y: auto;
    }

    .repo-item {
      display: grid;
      grid-template-columns: 1fr 100px 150px;
      gap: 16px;
      padding: 8px 16px;
      border-bottom: 1px solid #333;
      transition: background 0.2s;
      text-decoration: none;
      color: #a59d92;
    }

    .repo-item:hover {
      background: #2a2e2f;
    }

    .repo-content::-webkit-scrollbar {
      width: 8px;
    }

    .repo-content::-webkit-scrollbar-track {
      background: #242628;
    }

    .repo-content::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }

    .repo-content::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .search-container {
      padding: 4px 12px;

      border-radius: 20px;
      border: 1px solid #474747;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      height: 34px;/
    }

    .search-container input[type="search"] {
      border: none;
      background: transparent;
      outline: none;
      color: #b3b3b3 !important;
      width: 180px;
      font-size: 14px;
      padding: 4px 0;
    }

    /* Кнопка очистки для Firefox и Chrome */
    .search-container {
      position: relative;
    }

    .clear-search {
      position: absolute;
      right: 12px;
      top: 16.9px;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23e8e6e3' viewBox='0 0 20 20'%3E%3Cpath d='M14.348 5.652a1 1 0 10-1.414-1.414L10 7.172 7.066 4.238a1 1 0 10-1.414 1.414L8.586 8.586l-2.934 2.934a1 1 0 101.414 1.414L10 10l2.934 2.934a1 1 0 001.414-1.414L11.414 8.586l2.934-2.934z'/%3E%3C/svg%3E") no-repeat center;
      background-size: 16px 16px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .search-container.show-clear .clear-search {
      opacity: 1;
    }

    /* отключения встроенной кнопки очистки в Chrome */
    .search-container input[type="search"]::-webkit-search-cancel-button {
      -webkit-appearance: none;
      display: none;
    }

    mark {
      background-color: rgba(255, 255, 0, 0.4);
    }

    /* Данные столбца Downloads	по центру */
    table.version-table td:nth-child(5) {
      width: 10%;
      text-align: center;
    }

    .download-text {
      display: inline-block;
      transform: translateX(-1px);
      /* смещает содержимое влево, не влияя на соседний столбец */
    }

    .download-counter {
      position: relative;
      color: #a7a6a6b0;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 0.75em;
      transition: transform 0.2s ease;
      margin-left: 9px;
      cursor: default;
      white-space: nowrap;
    }

    .download-counter:hover {
      transform: scale(1.1);
    }

    .download-container {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 4px;
    }

    ::-webkit-scrollbar {
      background-color: #2a2a2a;
    }

    ::-webkit-scrollbar-thumb {
      background-color: #666;
    }

    ::-webkit-scrollbar-track {
      background-color: #3a3a3a;
    }

    .arch-filter-buttons {
      display: inline-flex;
      gap: 10px;
      padding: 8px;
      min-height: 50px;
      transition: opacity 0.3s ease;
      opacity: 1;
      height: auto;
      overflow: hidden;
    }

    .arch-filter-buttons.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .arch-filter-button {
      padding: 6px 12px;
      border: 1px solid #474747;
      background: transparent;
      color: #a6a7a7;
      border-radius: 20px;
      cursor: pointer;
      font-weight: 700;
      transition: all 0.3s ease;
    }

    .arch-filter-button.active {
      background: #1db954;
      color: #000;
      border: 1px solid #ffffff00;
    }

    .arch-filter-button:hover:not(.active) {
      background: #d6d6d62a;
    }

    tr.arch-filters-row {
      height: 50px;
      transition: height 0.3s ease;
    }

    tr.os-filters-row {
      position: relative;
      z-index: 2;
    }

    .search-container {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      height: 34px;
      transition: all 0.3s ease;
      overflow: hidden;
      width: 24px;
      border: none;
      background: transparent;
      padding: 0;
      position: relative;
    }

    .search-container.expanded {
      width: 220px;
      padding: 4px 12px;
      border-radius: 20px;
      border: 1px solid #474747;
      background: transparent;
      box-shadow: 0 0 0 rgba(29, 185, 84, 0);
      animation: search-glow 0.6s ease-out;
    }

    /* свечение для контейнера поиска */
    @keyframes search-glow {
      0% {
        box-shadow: 0 0 2px rgba(29, 185, 84, 0.3);
      }

      50% {
        box-shadow: 0 0 8px rgba(29, 185, 84, 0.5);
      }

      100% {
        box-shadow: 0 0 0 rgba(29, 185, 84, 0);
      }
    }

    /* стили для поля поиска с эффектом появления */
    .search-container input[type="search"] {
      border: none;
      background: transparent;
      outline: none;
      color: #b3b3b3 !important;
      width: 0;
      font-size: 14px;
      padding: 4px 0;
      transition: width 0.3s ease, opacity 0.3s ease 0.1s;
      opacity: 0;
      transform-origin: right center;
    }

    .search-container.expanded input[type="search"] {
      width: 180px;
      opacity: 1;
      animation: reveal-input 0.3s ease-in-out;
    }

    /* анимация для постепенного появления поля ввода */
    @keyframes reveal-input {
      0% {
        transform: scaleX(0.7);
        opacity: 0;
      }

      100% {
        transform: scaleX(1);
        opacity: 1;
      }
    }

  
    .search-icon {
      cursor: pointer;
      min-width: 24px;
      min-height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 2;
    }

    .search-icon svg {
      width: 24px;
      height: 24px;
      fill: #a6a7a7;
      display: block;
      transition: fill 0.3s ease, transform 0.2s ease;
    }

    .search-container.expanded .search-icon svg {
      fill: #1db954;
    }

    /* эффект нажатия на иконку */
    .search-icon:active svg {
      transform: scale(0.9);
    }

    table.version-table tbody td:nth-child(2),
    table.version-table tbody td:nth-child(3),
    table.version-table tbody td:nth-child(4),
    table.version-table tbody tr:not(:has(td.version-cell)) td:nth-child(1),
    table.version-table tbody tr:not(:has(td.version-cell)) td:nth-child(2),
    table.version-table tbody tr:not(:has(td.version-cell)) td:nth-child(3) {
      font-size: 13px;
    }

    .comment-button {
      background: transparent;
      border: none;
      color: #777;
      cursor: pointer;
      padding: 3px;
      margin-left: 5px;
      border-radius: 3px;
      opacity: 0.6;
      transition: all 0.2s ease;
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      vertical-align: top;
      z-index: 2;
      pointer-events: auto;
    }

    .comment-button:hover {
      opacity: 1;
      color: #1db954;
      background: rgba(29, 185, 84, 0.1);
    }

    .version-cell {
      position: relative;
      cursor: default;
    }

    .comments-modal {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(3px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .comments-modal.show {
      opacity: 1;
    }

    body.modal-open {
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    .comments-modal-content {
      background-color: #242628;
      margin: 0 auto;
      padding: 0;
      border-radius: 8px;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
    }

    .comments-modal-header {
      padding: 15px 20px;
      background-color: #1f2021;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
    }

    .comments-modal-title {
      margin: 0;
      color: #e8e6e3;
      font-size: 18px;
      font-weight: 700;
    }

    .comments-close-button {
      background: transparent;
      border: none;
      color: #888;
      font-size: 28px;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      padding: 0 5px;
    }

    .comments-close-button:hover {
      color: #1db954;
    }

    .comments-modal-body {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(90vh - 70px);
      min-height: 400px;
    }

    .comments-auth-notice {
      background-color: rgba(29, 185, 84, 0.1);
      border-left: 3px solid #1db954;
      padding: 12px 15px;
      margin: 15px 0;
      border-radius: 0 4px 4px 0;
    }

    .comments-auth-notice p {
      color: #b3b3b3;
      margin: 0;
      font-size: 14px;
    }

    /* улучшение адаптивности для мобильных устройств */
    @media (max-width: 768px) {
      .comments-modal-content {
        width: 95%;
        max-height: 95vh;
      }

      .comments-modal-body {
        padding: 15px;
      }
    }

    .giscus-frame {
      width: 100%;
      border: none;
      min-height: 300px;
    }

    .comment-button .comment-count {
      position: absolute;
      top: -5px;
      right: -5px;
      background-color: #444;
      color: #aaa;
      border-radius: 50%;
      font-size: 10px;
      min-width: 14px;
      height: 14px;
      text-align: center;
      line-height: 14px;
      font-weight: bold;
      transition: all 0.2s ease;
    }

    .comment-button.has-comments .comment-count {
      background-color: #e7a718;
      color: #000;
    }

  </style>
</head>

<body>
  <nav class="nav-container">
    <div class="navbar">
      <div class="nav-brand">
        <!-- место для лого слева -->
      </div>
      <ul class="nav-center">
        <li><a href="index.html" class="active" style="pointer-events: none; cursor: default;">Versions</a></li>
        <li><a href="help.html" style="pointer-events: none; cursor: default;">Help</a></li>
        <li><a href="links.html" style="pointer-events: none; cursor: default;">Links</a></li>
      </ul>
    </div>
  </nav>

  <header>
    <h1>Official Spotify full installers</h1>
    <p>Site is in test mode, send a <a href="https://github.com/LoaderSpot/table/issues/new" target="_blank"
        style="color: #1db954; text-decoration: none;">bug report</a></p>
  </header>

  <!-- Контейнер с таблицей -->
  <div class="container">
    <table class="version-table" id="versionsTable">
      <!-- Регулировки ширины столбцов -->
      <colgroup>
        <col style="width:15%"><!-- Version -->
        <col style="width:12%"><!-- Architecture -->
        <col style="width:12%"><!-- Date -->
        <col style="width:12%"><!-- Size -->
        <col style="width:10%"><!-- Кнопка -->
      </colgroup>
      <thead>
        <!-- ряд фильтрации: разделяем на два ряда -->
        <tr class="arch-filters-row">
          <td colspan="5">
            <!-- Фильтры архитектур над кнопками ОС -->
            <div id="arch-filters" class="arch-filter-buttons">
            </div>
          </td>
        </tr>
        <tr class="os-filters-row">
          <td colspan="5">
            <div class="filter-buttons" style="display: inline-flex; align-items: center; gap: 10px;">
              <button class="filter-button active" data-os="win">Windows</button>
              <button class="filter-button" data-os="mac">Mac</button>
              <button class="filter-button" data-os="linux">Linux</button>
              <!--блок поиска -->
              <div class="search-container" id="searchContainer">
                <span class="search-icon" id="searchIcon">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="2" fill="none" />
                    <line x1="15" y1="15" x2="20" y2="20" stroke="currentColor" stroke-width="2"
                      stroke-linecap="round" />
                  </svg>
                </span>
                <input type="search" id="versionSearch" placeholder="Search by version" style="font-size: 13px;">
                <span class="clear-search"></span>
              </div>
            </div>
          </td>
        </tr>
        <tr class="table-headers">
          <th>Version</th>
          <th>Architecture</th>
          <th>Date</th>
          <th>Size</th>
          <th> </th>
        </tr>
      </thead>
      <tbody id="versions-container">
        <!-- контейнер для спиннера и данных таблицы-->
      </tbody>
    </table>
  </div>

  <!-- Тост-уведомление (копирование) -->
  <div class="toast-notification" id="toast">Copied to clipboard</div>

  <script>
    const downloadIcon = `
      <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 15.575c-.183 0-.36-.073-.49-.203l-4.095-4.095a.694.694 0 01.981-.981L12 13.901l3.604-3.604a.694.694 0 01.981.98l-4.095 4.095a.692.692 0 01-.49.203z"/>
        <path d="M12 15.575a.694.694 0 01-.694-.694V3.694a.694.694 0 011.388 0v11.187c0 .383-.31.694-.694.694z"/>
        <path d="M16.306 20.306H7.694a4.167 4.167 0 01-4.162-4.163v-2.777a.694.694 0 011.388 0v2.777a2.778 2.778 0 002.774 2.775h8.612a2.778 2.778 0 002.775-2.775v-2.777a.694.694 0 011.387 0v2.777a4.167 4.167 0 01-4.162 4.163z"/>
      </svg>
    `;

    // Определяем ОС из URL параметров перед загрузкой данных
    let currentOS = (() => {
      const urlParams = new URLSearchParams(window.location.search);
      switch (true) {
        case urlParams.has('mac'):
          return 'mac';
        case urlParams.has('linux'):
          return 'linux';
        default:
          return 'win'; // Default is Windows
      }
    })();

    // Обновляем активную вкладку в UI при загрузке страницы
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.filter-button').forEach(btn => {
        if (btn.dataset.os === currentOS) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    });

    // Функция отображения тоста
    function showToast(message) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 2000);
    }

    // Функция fallback для копирования текста
    function fallbackCopyTextToClipboard(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.top = '0';
      textArea.style.left = '0';
      textArea.style.width = '2em';
      textArea.style.height = '2em';
      textArea.style.padding = '0';
      textArea.style.border = 'none';
      textArea.style.outline = 'none';
      textArea.style.boxShadow = 'none';
      textArea.style.background = 'transparent';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        document.execCommand('copy');
        showToast('Copied to clipboard');
      } catch (err) {
        showToast('Error while copying');
        console.error('Error while copying:', err);
      }
      document.body.removeChild(textArea);
    }

    // Глобальный кэш для результатов HEAD-запросов
    const headCache = new Map();

    // Флаг для отслеживания необходимости отложить HEAD-запросы
    let headRequestsStarted = false;

    // Таймер для начала HEAD-запросов даже если Worker не ответил
    let headRequestsTimer = null;

    // Очередь HEAD-запросов
    const pendingHeadRequests = [];

    // Функция для выполнения отложенных HEAD-запросов
    function processPendingHeadRequests() {
      if (headRequestsStarted) return; // Если запросы уже запущены, не запускаем снова

      headRequestsStarted = true;
      // Отменяем таймер, если он был установлен
      if (headRequestsTimer) {
        clearTimeout(headRequestsTimer);
        headRequestsTimer = null;
      }

      // Выполняем все HEAD-запросы из очереди
      for (const request of pendingHeadRequests) {
        executeHeadRequest(request.dateCell, request.sizeCell, request.url);
      }
      pendingHeadRequests.length = 0; // Очищаем очередь
    }

    // Функция updateLinkInfo с использованием очереди
    function updateLinkInfo(dateCell, sizeCell, url) {
      // Добавляем запрос в очередь
      pendingHeadRequests.push({ dateCell, sizeCell, url });

      // Если запросы уже запущены, выполняем немедленно
      if (headRequestsStarted) {
        executeHeadRequest(dateCell, sizeCell, url);
        // И удаляем из очереди
        const index = pendingHeadRequests.findIndex(req =>
          req.dateCell === dateCell && req.sizeCell === sizeCell && req.url === url);
        if (index > -1) {
          pendingHeadRequests.splice(index, 1);
        }
      }
    }

    // Функция для выполнения HEAD-запроса
    async function executeHeadRequest(dateCell, sizeCell, url) {
      if (headCache.has(url)) {
        const cached = headCache.get(url);
        dateCell.textContent = cached.date;
        sizeCell.textContent = cached.size;
        return;
      }
      try {
        const response = await fetch(url, { method: 'HEAD' });
        const lastModified = response.headers.get('Last-Modified');
        const contentLength = response.headers.get('Content-Length');
        let formattedDate = '—';
        let sizeMb = '—';
        if (lastModified) {
          const date = new Date(lastModified);
          formattedDate =
            String(date.getDate()).padStart(2, '0') + '.' +
            String(date.getMonth() + 1).padStart(2, '0') + '.' +
            date.getFullYear();
        }
        if (contentLength) {
          sizeMb = (parseInt(contentLength, 10) / (1024 * 1024)).toFixed(2) + ' MB';
        }
        // Сохраняем результат в кэше
        headCache.set(url, { date: formattedDate, size: sizeMb });
        dateCell.textContent = formattedDate;
        sizeCell.textContent = sizeMb;
      } catch (error) {
        console.error('Error getting headers', error);
        dateCell.textContent = '—';
        sizeCell.textContent = '—';
        headCache.set(url, { date: '—', size: '—' });
      }
    }

    // Функция для генерации ключа счетчика
    const generateCounterKey = (version, os, arch) => `${version}-${os}-${arch}`;

    // Глобальный кэш для всех счетчиков скачиваний, полученных из Worker
    let allDownloadCounters = {};
    // Флаг для отслеживания загрузки счетчиков
    let countersLoaded = false;
    // Хранилище для ожидающих элементов UI, которые нужно обновить после загрузки счетчиков
    const pendingCounterElements = new Map();

    // Функция для получения всех счетчиков одним запросом
    async function loadAllDownloadCounters() {
      try {
        const workerUrl = 'https://broad-pine-bbc0.amd64fox1.workers.dev/?all=true';
        // Таймаут для запроса к Worker - 3 секунды
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);

        const response = await fetch(workerUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        allDownloadCounters = await response.json();
        countersLoaded = true;

        // Обновляем все ожидающие элементы UI с правильным форматированием
        pendingCounterElements.forEach((counterInfo, counterKey) => {
          const count = allDownloadCounters[counterKey] || "0";
          counterInfo.element.innerHTML = count === "0" ? "" :
            `<span class="download-counter">${formatDownloadCount(count)}</span>`;
        });
        pendingCounterElements.clear();

        // Разрешаем начать HEAD-запросы после получения счетчиков
        processPendingHeadRequests();
      } catch (err) {
        console.error('Error loading all download counters:', err);
        countersLoaded = true; // помечаем как загруженные, чтобы избежать повторных запросов

        // Запускаем HEAD-запросы даже при ошибке загрузки счетчиков
        processPendingHeadRequests();
      }
    }

    // функцию форматирования счетчика скачиваний
    function formatDownloadCount(count) {
      count = parseInt(count, 10);

      const suffix = count === 1 ? "download" : "downloads";

      if (count < 1000) {
        return `${count} ${suffix}`;
      }

      const units = ['', 'k', 'm'];
      const unit = count < 1000000 ? units[1] : units[2];
      const value = count < 1000000 ? count / 1000 : count / 1000000;

      let formatted = value.toFixed(1);

      if (formatted.endsWith('.0')) {
        formatted = formatted.slice(0, -2);
      }

      return `${formatted}${unit} ${suffix}`;
    }

    function updateDownloadCount(fileUrl, countElement, version, os, arch) {
      const counterKey = generateCounterKey(version, os, arch);

      if (countersLoaded) {
        // Если данные уже загружены, используем их
        const count = allDownloadCounters[counterKey] || "0";
        countElement.innerHTML = count === "0" ? "" : `<span class="download-counter">${formatDownloadCount(count)}</span>`;
      } else {
        // Сохраняем элемент для отложенного обновления
        pendingCounterElements.set(counterKey, { element: countElement, url: fileUrl });
      }
    }

    // Функция для обработки событий скачивания
    function handleDownload(downloadLink, fileUrl, version, os, arch) {

      const countElement = downloadLink.closest('.download-container').querySelector('div');
      const counterKey = generateCounterKey(version, os, arch);

      // Увеличиваем счетчик в глобальном объекте
      const newCount = (parseInt(allDownloadCounters[counterKey] || "0", 10) + 1).toString();
      allDownloadCounters[counterKey] = newCount;

      // Обновляем UI с новым значением
      countElement.innerHTML = newCount === "0" ? "" :
        `<span class="download-counter">${formatDownloadCount(newCount)}</span>`;

      // скачивание файла не дожидаясь ответа от воркера
      window.open(fileUrl, '_blank');

      fetch(`https://broad-pine-bbc0.amd64fox1.workers.dev/?counter=${encodeURIComponent(counterKey)}`, {
        method: 'GET',
        cache: 'no-store', // Не кэшировать запрос
        mode: 'cors',      // CORS режим
        redirect: 'manual' // Не следовать редиректам
      }).catch(err => {
        console.error('Worker counter update error:', err);
      });
    }

    // Кэш для регулярных выражений
    const regexCache = new Map();

    // Подсветки найденного текста с кэшированием регулярных выражений
    function highlight(text, term) {
      if (!term) return text;

      // Используем кэшированное регулярное выражение или создаём новое
      if (!regexCache.has(term)) {
        // Экранируем специальные символы в поисковом запросе
        const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        regexCache.set(term, new RegExp(`(${escapedTerm})`, 'gi'));
      }

      return text.replace(regexCache.get(term), '<mark>$1</mark>');
    }

    // Глобальная переменная для архитектурного фильтра
    let currentArch = 'all';

    // Функция обновления фильтров архитектур
    function updateArchFilters() {
      const archContainer = document.getElementById('arch-filters');

      // Для Linux скрываем фильтры архитектур, а не очищаем контейнер
      if (currentOS === 'linux') {
        archContainer.classList.add('hidden');
        return;
      }

      // Для других OS показываем и заполняем фильтрами
      archContainer.classList.remove('hidden');
      archContainer.innerHTML = ''; // очистка содержимого

      const archSet = new Set();
      // Собираем архитектуры из всех версий для текущей ОС
      allVersions.forEach(([, data]) => {
        if (data.links[currentOS]) {
          Object.keys(data.links[currentOS]).forEach(arch => archSet.add(arch));
        }
      });
      let archArr = [];
      if (currentOS === 'win') {
        // для Windows фиксированный порядок, если присутствуют в данных
        const order = ["x86", "x64", "arm64"];
        archArr = order.filter(arch => archSet.has(arch));
      } else if (currentOS === 'mac') {
        // для mac фиксированный порядок, если присутствуют в данных
        const order = ["intel", "arm64"];
        archArr = order.filter(arch => archSet.has(arch));
      } else {
        archArr = Array.from(archSet).sort();
      }
      // Создаем по кнопке для каждой архитектуры
      archArr.forEach(arch => {
        const btn = document.createElement('button');
        btn.className = 'arch-filter-button' + (currentArch === arch ? ' active' : '');
        btn.textContent = arch;
        btn.addEventListener('click', () => {
          // Если нажата уже активная кнопка, сбрасываем фильтр (возвращаемся к "всему")
          if (currentArch === arch) {
            currentArch = 'all';
          } else {
            currentArch = arch;
          }
          updateArchFilters();
          reRenderVersions();
        });
        archContainer.appendChild(btn);
      });
    }

    // Функция для повторного рендера версий с учетом текущих фильтров (ОС + архитектура + поиск)
    function reRenderVersions() {
      container.style.opacity = "0";
      observer.unobserve(sentinel);

      setTimeout(() => {
        // Сбрасываем текущие результаты поиска, если они были
        if (currentSearchTerm !== "") {
          // Если есть активный поиск, повторно выполняем его с учетом нового фильтра архитектуры
          performSearch(currentSearchTerm);
        } else {
          // В противном случае просто перезагружаем данные с новым фильтром архитектуры
          currentSearchResults = null;
          startLazyLoading();
        }
      }, 300);
    }

    // Функция для создания строк таблицы для одной версии
    function createVersionRows(versionKey, data, searchTerm = '') {
      const shortVersion = versionKey;
      const archCombos = [];
      let totalRowsForVersion = 0;

      // Фильтруем только по текущей ОС
      if (data.links[currentOS]) {
        for (const arch of Object.keys(data.links[currentOS])) {
          // Фильтруем по архитектуре, если выбран конкретный
          if (currentArch !== 'all' && arch !== currentArch) continue;
          const link = data.links[currentOS][arch];
          if (link) {
            archCombos.push({ arch, link });
            totalRowsForVersion++;
          }
        }
      }

      if (totalRowsForVersion === 0) return [];

      const rows = [];
      let isFirstVersionRow = true;

      archCombos.forEach((combo) => {
        const row = document.createElement('tr');

        if (isFirstVersionRow) {
          const versionCell = document.createElement('td');
          versionCell.className = 'version-cell';
          versionCell.rowSpan = totalRowsForVersion;

          // Используем подсветку, если searchTerm непустой
          const displayedShort = searchTerm ? highlight(shortVersion, searchTerm) : shortVersion;
          const displayedFull = searchTerm ? highlight(data.fullversion, searchTerm) : data.fullversion;
          const versionText = document.createElement('div');
          versionText.className = 'version-text';

          // Создаем отдельные элементы для короткой и полной версий
          const shortVersionElem = document.createElement('span');
          shortVersionElem.className = 'short-version';
          shortVersionElem.innerHTML = displayedShort;
          shortVersionElem.addEventListener('click', async () => {
            try {
              if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(shortVersion);
                showToast('Short version copied to clipboard');
              } else {
                fallbackCopyTextToClipboard(shortVersion);
              }
            } catch (err) {
              console.error('Error while copying:', err);
              fallbackCopyTextToClipboard(shortVersion);
            }
          });

          const fullVersionElem = document.createElement('span');
          fullVersionElem.className = 'full-version';
          fullVersionElem.innerHTML = displayedFull;
          fullVersionElem.addEventListener('click', async () => {
            try {
              if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(data.fullversion);
                showToast('Full version copied to clipboard');
              } else {
                fallbackCopyTextToClipboard(data.fullversion);
              }
            } catch (err) {
              console.error('Error while copying:', err);
              fallbackCopyTextToClipboard(data.fullversion);
            }
          });

          // Добавляем оба элемента в родительский контейнер
          versionText.appendChild(shortVersionElem);
          versionText.appendChild(fullVersionElem);

          // Убираем прежний обработчик с родительского элемента
          versionCell.appendChild(versionText);
          row.appendChild(versionCell);
          isFirstVersionRow = false;
        }

        // Архитектура
        const archCell = document.createElement('td');
        archCell.textContent = combo.arch;
        row.appendChild(archCell);

        // Дата
        const dateCell = document.createElement('td');
        dateCell.textContent = '—';
        row.appendChild(dateCell);

        // Размер
        const sizeCell = document.createElement('td');
        sizeCell.textContent = '—';
        row.appendChild(sizeCell);

        // Кнопка скачать с отображением счётчика
        const actionCell = document.createElement('td');
        actionCell.className = 'action-cell';
        const downloadContainer = document.createElement('div');
        downloadContainer.className = 'download-container';
        const downloadLink = document.createElement('a');
        downloadLink.className = 'download-link';

        // Заменяем href:
        downloadLink.removeAttribute('href');

        // Формируем тултип в зависимости от OS
        let extension = '';
        if (currentOS === 'win') {
          extension = '.exe';
        } else if (currentOS === 'mac') {
          extension = '.tbz';
        } else if (currentOS === 'linux') {
          extension = '.deb';
        }
        downloadLink.title = `download ${shortVersion}-${combo.arch}${extension}`;

        downloadLink.addEventListener('click', (e) => {
          e.preventDefault();
          // Используем обновленную функцию обработки скачивания
          handleDownload(downloadLink, combo.link, shortVersion, currentOS, combo.arch);
        });

        downloadLink.innerHTML = downloadIcon;
        downloadContainer.appendChild(downloadLink);

        // Отображения счетчика скачиваний
        const downloadCountSpan = document.createElement('div');
        downloadCountSpan.style.fontSize = 'small';
        downloadContainer.appendChild(downloadCountSpan);
        actionCell.appendChild(downloadContainer);
        row.appendChild(actionCell);

        // Обновляем инфу о дате и размере
        updateLinkInfo(dateCell, sizeCell, combo.link);
        // Запрашиваем и обновляем счетчик скачиваний с новым форматом ключа
        updateDownloadCount(combo.link, downloadCountSpan, shortVersion, currentOS, combo.arch);

        rows.push(row);
      });

      return rows;
    }

    // Переменные для "ленивой" подгрузки
    let allVersions = [];
    const ITEMS_PER_BATCH = 5; // по 5 версий за раз
    let currentIndex = 0;
    let currentSearchResults = null; // Новая переменная для результатов поиска
    const container = document.getElementById('versions-container');

    // Глобальная переменная для хранения Linux-пакетов
    let linuxVersionsData = [];
    let currentSearchTerm = '';
    let linuxDataLoaded = false; // Флаг успешной загрузки Linux-данных

    // Невидимый "сторож" для Intersection Observer
    const sentinel = document.createElement('tr');
    sentinel.style.height = '1px';

    // Создаем универсальный Intersection Observer для всех типов данных
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          observer.unobserve(sentinel);

          // Загружаем следующую партию данных в зависимости от текущей ОС
          if (currentOS === 'linux') {
            loadMoreLinuxRows();
          } else {
            loadMoreWinMacRows();
          }

          // Если есть еще данные для загрузки, снова подключаем наблюдателя
          const currentSource = getCurrentDataSource();
          if (currentIndex < currentSource.length) {
            observer.observe(sentinel);
          }
        }
      });
    }, { root: null, rootMargin: '100px', threshold: 0 });

    // Функция для получения текущего источника данных в зависимости от ОС и поиска
    function getCurrentDataSource() {
      if (currentOS === 'linux') {
        return currentSearchResults || linuxVersionsData;
      } else {
        return currentSearchResults || allVersions;
      }
    }

    // Функция для создания строк таблицы для Linux-пакетов с поддержкой ленивой загрузки
    function loadMoreLinuxRows() {
      const dataSource = currentSearchResults || linuxVersionsData;
      const endIndex = Math.min(currentIndex + ITEMS_PER_BATCH, dataSource.length);

      for (let i = currentIndex; i < endIndex; i++) {
        const version = dataSource[i];

        // Создаем строки для версии и ее архитектур
        const versionCell = document.createElement('td');
        versionCell.className = 'version-cell';
        versionCell.rowSpan = version.architectures.length;

        const versionText = document.createElement('div');
        versionText.className = 'version-text';

        // Подсвечиваем совпадения, если есть поисковый запрос
        const displayedShort = currentSearchTerm ?
          highlight(version.version.short, currentSearchTerm) : version.version.short;
        const displayedFull = currentSearchTerm ?
          highlight(version.version.full, currentSearchTerm) : version.version.full;

        // Создаем отдельные элементы для короткой и полной версий
        const shortVersionElem = document.createElement('span');
        shortVersionElem.className = 'short-version';
        shortVersionElem.innerHTML = displayedShort;
        shortVersionElem.addEventListener('click', () => {
          navigator.clipboard.writeText(version.version.short)
            .then(() => showToast('Short version copied to clipboard'))
            .catch(() => fallbackCopyTextToClipboard(version.version.short));
        });

        const fullVersionElem = document.createElement('span');
        fullVersionElem.className = 'full-version';
        fullVersionElem.innerHTML = displayedFull;
        fullVersionElem.addEventListener('click', () => {
          navigator.clipboard.writeText(version.version.full)
            .then(() => showToast('Full version copied to clipboard'))
            .catch(() => fallbackCopyTextToClipboard(version.version.full));
        });

        // Добавляем оба элемента в родительский контейнер
        versionText.appendChild(shortVersionElem);
        versionText.appendChild(fullVersionElem);

        versionCell.appendChild(versionText);

        version.architectures.forEach((arch, index) => {
          const row = document.createElement('tr');
          if (index === 0) {
            row.appendChild(versionCell);
          }
          const archCell = document.createElement('td');
          archCell.textContent = arch.arch;
          row.appendChild(archCell);

          const dateCell = document.createElement('td');
          dateCell.textContent = arch.date;
          row.appendChild(dateCell);

          const sizeCell = document.createElement('td');
          sizeCell.textContent = arch.size;
          row.appendChild(sizeCell);

          // Кнопка скачать с обновлением счетчика
          const actionCell = document.createElement('td');
          actionCell.className = 'action-cell';
          const downloadContainer = document.createElement('div');
          downloadContainer.className = 'download-container';
          const downloadLink = document.createElement('a');
          downloadLink.className = 'download-link';
          downloadLink.removeAttribute('href');

          downloadLink.title = `download ${version.version.short}-${arch.arch}.deb`;

          downloadLink.addEventListener('click', (e) => {
            e.preventDefault();
            handleDownload(downloadLink, arch.link, version.version.short, 'linux', arch.arch);
          });

          downloadLink.innerHTML = downloadIcon;
          downloadContainer.appendChild(downloadLink);

          const downloadCountSpan = document.createElement('div');
          downloadCountSpan.style.fontSize = 'small';
          downloadContainer.appendChild(downloadCountSpan);
          actionCell.appendChild(downloadContainer);
          row.appendChild(actionCell);

          // Добавляем строку в контейнер
          container.appendChild(row);
          updateDownloadCount(arch.link, downloadCountSpan, version.version.short, 'linux', arch.arch);
        });
      }

      currentIndex = endIndex;
      if (currentIndex < dataSource.length) {
        container.appendChild(sentinel);
      }
    }

    // Функция для Windows/Mac ленивой загрузки
    function loadMoreWinMacRows() {
      const dataSource = currentSearchResults || allVersions;
      const endIndex = Math.min(currentIndex + ITEMS_PER_BATCH, dataSource.length);

      for (let i = currentIndex; i < endIndex; i++) {
        const [versionKey, versionData] = dataSource[i];
        const versionRows = createVersionRows(versionKey, versionData, currentSearchTerm);
        versionRows.forEach(r => container.appendChild(r));
      }

      currentIndex = endIndex;
      if (currentIndex < dataSource.length) {
        container.appendChild(sentinel);
      }
    }


    // Загрузка данных для Linux с поддержкой ленивой загрузки
    async function loadLinuxPackages() {
      try {
        const response = await fetch('versions_deb.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const linuxData = await response.json();

        // Преобразуем данные для удобства
        linuxVersionsData = Object.entries(linuxData).map(([versionKey, data]) => {
          return {
            version: {
              short: versionKey,
              full: data.fullversion
            },
            architectures: Object.entries(data.links).map(([arch, link]) => {
              // Рассчитываем размер в MB
              const sizeInMB = data.size ?
                (parseInt(data.size, 10) / (1024 * 1024)).toFixed(2) + ' MB' :
                '—';

              return {
                arch,
                link,
                date: data.data || '—',
                size: sizeInMB
              };
            })
          };
        });

        // Сортируем версии (новые первыми)
        linuxVersionsData.sort((a, b) => {
          return b.version.short.localeCompare(a.version.short, undefined, { numeric: true });
        });

        linuxDataLoaded = true;

        // Отображаем данные с учетом текущих фильтров
        startLazyLoading();
      } catch (error) {
        console.error('Ошибка загрузки Linux пакетов:', error);
        container.innerHTML = '<tr><td colspan="5">Ошибка загрузки списка пакетов</td></tr>';
      }
    }

    // Унифицированная функция для запуска ленивой загрузки в зависимости от ОС
    function startLazyLoading() {
      container.innerHTML = '';
      currentIndex = 0;

      const dataSource = getCurrentDataSource();

      if (dataSource.length === 0) {
        container.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px;">No results</td></tr>';
        container.style.opacity = "1";
        return;
      }

      // Загружаем первую порцию в зависимости от ОС
      if (currentOS === 'linux') {
        loadMoreLinuxRows();
      } else {
        loadMoreWinMacRows();
      }

      // Если есть еще данные для загрузки, подключаем наблюдателя
      if (currentIndex < dataSource.length) {
        observer.observe(sentinel);
      }

      container.style.opacity = "1";
    }

    // Функция для сортировки результатов поиска для Win/Mac
    function sortSearchResults(filtered, term) {
      return filtered.sort((a, b) => {
        const [versionKeyA, dataA] = a;
        const [versionKeyB, dataB] = b;

        const fullVersionA = dataA.fullversion.toLowerCase();
        const fullVersionB = dataB.fullversion.toLowerCase();

        // Проверяем точное совпадение целого числа (окруженного точками или границами строки)
        const termWithBoundaries = `(^|\\.|\\ )${term}($|\\.|\\s)`;
        const reExact = new RegExp(termWithBoundaries);

        const exactMatchA = reExact.test(versionKeyA.toLowerCase()) || reExact.test(fullVersionA);
        const exactMatchB = reExact.test(versionKeyB.toLowerCase()) || reExact.test(fullVersionB);

        // Если у одного точное совпадение, а у другого нет
        if (exactMatchA && !exactMatchB) return -1;
        if (!exactMatchA && exactMatchB) return 1;

        // Проверяем совпадение в первой части версии (до 'g')
        // Разделяем версию на основную часть и хеш
        const mainPartA = fullVersionA.split('g')[0];
        const mainPartB = fullVersionB.split('g')[0];

        const inMainA = mainPartA.includes(term);
        const inMainB = mainPartB.includes(term);

        // Приоритизируем совпадения в основной части версии
        if (inMainA && !inMainB) return -1;
        if (!inMainA && inMainB) return 1;

        // Сортируем по версии (сначала новые)
        return versionKeyB.localeCompare(versionKeyA, undefined, { numeric: true, sensitivity: 'base' });
      });
    }

    // Унифицированная функция поиска для всех OS
    function performSearch(term) {
      term = term.trim().toLowerCase();
      container.style.opacity = "0";
      currentSearchTerm = term;
      observer.unobserve(sentinel);

      setTimeout(() => {
        if (term === "") {
          currentSearchResults = null;
          startLazyLoading();
          return;
        }

        // Очищаем контейнер
        container.innerHTML = "";
        currentIndex = 0;

        // Проверяем, загружены ли данные для Linux, если это текущая ОС
        if (currentOS === 'linux' && !linuxDataLoaded) {
          loadLinuxPackages();
          return;
        }

        // Выполняем поиск в зависимости от текущей ОС
        if (currentOS === 'linux') {
          // Поиск по Linux-данным
          currentSearchResults = linuxVersionsData.filter(version =>
            version.version.short.toLowerCase().includes(term) ||
            version.version.full.toLowerCase().includes(term)
          ).sort((a, b) => {
            // Логика сортировки для Linux
            const shortA = a.version.short.toLowerCase();
            const shortB = b.version.short.toLowerCase();
            const fullA = a.version.full.toLowerCase();
            const fullB = b.version.full.toLowerCase();

            // Проверяем точное совпадение
            const termWithBoundaries = `(^|\\.|\\ )${term}($|\\.|\\s)`;
            const reExact = new RegExp(termWithBoundaries);

            const exactMatchA = reExact.test(shortA) || reExact.test(fullA);
            const exactMatchB = reExact.test(shortB) || reExact.test(fullB);

            if (exactMatchA && !exactMatchB) return -1;
            if (!exactMatchA && exactMatchB) return 1;

            // Проверяем совпадение в основной части
            const mainPartA = fullA.split('g')[0];
            const mainPartB = fullB.split('g')[0];

            const inMainA = mainPartA.includes(term);
            const inMainB = mainPartB.includes(term);

            if (inMainA && !inMainB) return -1;
            if (!inMainA && inMainB) return 1;

            // Сортируем по версии
            return b.version.short.localeCompare(a.version.short, undefined, { numeric: true });
          });
        } else {
          // Поиск для Windows и Mac (существующая логика)
          const filtered = allVersions.filter(([versionKey, data]) => {
            return (versionKey.toLowerCase().includes(term) ||
              data.fullversion.toLowerCase().includes(term)) &&
              data.links[currentOS] &&
              (currentArch === 'all' || data.links[currentOS].hasOwnProperty(currentArch));
          });

          currentSearchResults = sortSearchResults(filtered, term);
        }

        // Запускаем ленивую загрузку результатов поиска
        startLazyLoading();
      }, 300);
    }

    async function initializeApp() {
      try {
        const response = await fetch('versions.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        container.innerHTML = ''; // Очищаем спиннер загрузки данных
        allVersions = Object.entries(data);

        // Запускаем загрузку счетчиков скачиваний для всех версий
        loadAllDownloadCounters().catch(err => console.error('Counter fetch error:', err));

        // Устанавливаем таймер для запуска HEAD-запросов если Worker не отвечает
        headRequestsTimer = setTimeout(() => {
          console.log('Starting HEAD requests after timeout');
          processPendingHeadRequests();
        }, 2000);

        // Отображаем первую партию данных для текущей ОС
        if (currentOS === 'linux') {
          loadLinuxPackages();
        } else {
          startLazyLoading();
          updateArchFilters();
        }
      } catch (err) {
        console.error('Error loading version data:', err);
        container.innerHTML = '<tr><td colspan="5">Failed to load version data.</td></tr>';
      }
    }

    // Обработчик для переключения вкладок (фильтрации по ОС)
    document.querySelectorAll('.filter-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.filter-button').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');

        const newOS = button.dataset.os;
        // Если ОС не изменилась, не выполняем лишних действий
        if (newOS === currentOS) return;

        // Сбрасываем фильтр архитектуры при переходе на Linux
        if (newOS === 'linux' && currentArch !== 'all') {
          currentArch = 'all'; // Сбросить фильтр архитектуры на "все"
        }

        currentOS = newOS;

        // Сброс фильтра архитектуры при необходимости
        if (currentOS !== 'linux') {
          let availableArch = new Set();
          allVersions.forEach(([, data]) => {
            if (data.links[currentOS]) {
              Object.keys(data.links[currentOS]).forEach(arch => availableArch.add(arch));
            }
          });
          if (!availableArch.has(currentArch)) {
            currentArch = 'all';
          }
        }

        // Анимация перехода
        container.style.opacity = "0";

        // Обновляем фильтры архитектур
        updateArchFilters();

        setTimeout(() => {
          // Если мы переходим на Linux и данные еще не загружены, загружаем их
          if (currentOS === 'linux' && !linuxDataLoaded) {
            loadLinuxPackages();
          } else {
            // Если поисковый запрос активен, обновляем поиск для новой ОС
            if (currentSearchTerm !== "") {
              performSearch(currentSearchTerm);
            } else {
              // Иначе просто перерисовываем данные
              currentSearchResults = null;
              startLazyLoading();
            }
          }
        }, 300);
      });
    });

    // Обработчик для поиска по версиям с ленивой загрузкой результатов
    const versionSearch = document.getElementById('versionSearch');
    const searchContainer = document.getElementById('searchContainer');
    const clearSearchBtn = document.querySelector('.clear-search');

    versionSearch.addEventListener('input', (e) => {
      const term = e.target.value.trim().toLowerCase();
      if (e.target.value.trim() !== "") {
        searchContainer.classList.add('show-clear');
      } else {
        searchContainer.classList.remove('show-clear');
      }
      performSearch(term);
    });

    // Обработчик клика на кнопку очистки
    clearSearchBtn.addEventListener('click', () => {
      versionSearch.value = '';
      searchContainer.classList.remove('show-clear');
      performSearch('');
      versionSearch.focus();
    });

    // Добавляем логику для сворачивания/разворачивания поиска
    const searchIcon = document.getElementById('searchIcon');

    // Функция для переключения состояния поиска
    function toggleSearch() {
      if (searchContainer.classList.contains('expanded')) {
        // Если поисковый запрос пуст, сворачиваем поиск
        if (versionSearch.value.trim() === '') {
          searchContainer.classList.remove('expanded');
        }
      } else {
        // Разворачиваем поиск
        searchContainer.classList.add('expanded');
        // Устанавливаем фокус на поле поиска после небольшой задержки для анимации
        setTimeout(() => versionSearch.focus(), 300);
      }
    }

    // Обработчик нажатия на иконку поиска
    searchIcon.addEventListener('click', () => {
      toggleSearch();
    });

    // Обработчик потери фокуса для сворачивания при клике вне поля поиска
    document.addEventListener('click', (e) => {
      // Если клик вне контейнера поиска и поле поиска пусто
      if (!searchContainer.contains(e.target) && versionSearch.value.trim() === '') {
        searchContainer.classList.remove('expanded');
      }
    });

    // Отменяем всплытие события при клике на контейнер поиска,
    // чтобы не срабатывал обработчик document.click
    searchContainer.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Запускаем инициализацию приложения
    initializeApp();

    // Код для работы с комментариями по версиям
    const commentsModal = document.createElement('div');
    commentsModal.className = 'comments-modal';
    commentsModal.innerHTML = `
      <div class="comments-modal-content">
        <div class="comments-modal-header">
          <h3 class="comments-modal-title">Comments for version <span id="comment-version-title"></span></h3>
          <button class="comments-close-button">&times;</button>
        </div>
        <div class="comments-modal-body" id="comments-container">
          <!-- Здесь будет инициализирован giscus -->
        </div>
      </div>
    `;
    document.body.appendChild(commentsModal);

    // Функция для удаления giscus фрейма и скрипта
    function cleanupGiscus() {
      const commentsContainer = document.getElementById('comments-container');
      if (commentsContainer) {
        commentsContainer.innerHTML = '';
      }
      
      const oldGiscusFrame = document.querySelector('iframe.giscus-frame');
      if (oldGiscusFrame) {
        oldGiscusFrame.remove();
      }
      
      const oldGiscusScript = document.getElementById('giscus-comments-script');
      if (oldGiscusScript) {
        oldGiscusScript.remove();
      }
    }

    // Отслеживаем загрузку giscus
    let giscusLoaded = false;
    let currentCommentVersion = '';
    let scrollPosition = 0; // Сохраняем позицию прокрутки

    // Функция открытия модального окна с блокировкой прокрутки основной страницы
    function openModal() {
      // Сохраняем текущую позицию прокрутки
      scrollPosition = window.pageYOffset;
      // Добавляем класс для фиксации тела документа
      document.body.classList.add('modal-open');
      // Устанавливаем top для имитации той же позиции после фиксации
      document.body.style.top = `-${scrollPosition}px`;
      // Отображаем модальное окно (сначала с opacity:0)
      commentsModal.style.display = 'flex';
      
      // Добавляем небольшую задержку перед показом для плавности
      setTimeout(() => {
        commentsModal.classList.add('show');
      }, 10);
    }

    // Функция закрытия модального окна с восстановлением прокрутки
    function closeModal() {
      // Анимация скрытия
      commentsModal.classList.remove('show');
      
      // Ждем завершения анимации перед полным скрытием
      setTimeout(() => {
        // Скрываем модальное окно
        commentsModal.style.display = 'none';
        // Удаляем класс для фиксации тела документа
        document.body.classList.remove('modal-open');
        // Удаляем стиль top
        document.body.style.top = '';
        // Восстанавливаем позицию прокрутки
        window.scrollTo(0, scrollPosition);
        // Очищаем контент giscus
        cleanupGiscus();
        
        // Обновляем счетчики комментариев после закрытия модального окна
        if (currentCommentVersion) {
          refreshCommentCountForVersion(currentCommentVersion);
        }
      }, 300); // Задержка должна соответствовать времени transition для opacity
    }

    // Слушаем сообщения от giscus iframe
    window.addEventListener('message', function (e) {
      if (e.origin !== 'https://giscus.app') return;

      try {
        // Проверяем, что данные - это строка JSON, а не объект
        const data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

        // Проверяем, что это сообщение от giscus
        if (data.giscus) {
          giscusLoaded = true;
          
          // Проверяем, содержит ли сообщение информацию о добавлении комментария
          if (data.giscus.discussion && currentCommentVersion) {
            // Если это событие добавления комментария
            if (data.giscus.discussion.totalCommentCount !== undefined) {
              // Обновляем кэш счетчика комментариев для текущей версии
              const newCount = data.giscus.discussion.totalCommentCount;
              
              // Обновляем кэш только если значение изменилось
              if (commentCountCache[currentCommentVersion] !== newCount) {
                commentCountCache[currentCommentVersion] = newCount;
                
                // Обновляем счетчик на главной странице
                updateCommentCountForVersion(currentCommentVersion, newCount);
              }
            }
          }
          
          // Отслеживаем события создания и удаления комментариев
          if (data.giscus.error === null && data.giscus.eventName) {
            // Если произошло событие комментирования, обновляем счетчик
            if (data.giscus.eventName === 'comment' || 
                data.giscus.eventName === 'reply') {
              
              // Небольшая задержка для обновления счетчика после действия
              setTimeout(() => {
                if (currentCommentVersion) {
                  refreshCommentCountForVersion(currentCommentVersion);
                }
              }, 1000);
            }
          }
        }
      } catch (error) {
        console.log('Error processing giscus message:', error);
      }
    });

    // Обработчик закрытия модального окна
    document.querySelector('.comments-close-button').addEventListener('click', closeModal);

    // Закрытие модального окна при клике вне содержимого
    window.addEventListener('click', (e) => {
      if (e.target === commentsModal) {
        closeModal();
      }
    });

    // Функция открытия модального окна с комментариями для версии
    function openComments(version) {
      
      // Устанавливаем заголовок
      document.getElementById('comment-version-title').textContent = version;
      const commentsContainer = document.getElementById('comments-container');
      
      // Очищаем предыдущие комментарии
      cleanupGiscus();
      
      // giscus config
      const giscusScript = document.createElement('script');
      giscusScript.id = 'giscus-comments-script';
      giscusScript.src = 'https://giscus.app/client.js';
      giscusScript.setAttribute('data-repo', 'LoaderSpot/table');
      giscusScript.setAttribute('data-repo-id', 'R_kgDOOANMeQ');
      giscusScript.setAttribute('data-category', 'Comments');
      giscusScript.setAttribute('data-category-id', 'DIC_kwDOOANMec4Cn2gF');
      giscusScript.setAttribute('data-mapping', 'specific');
      giscusScript.setAttribute('data-term', `spotify-version-${version}`);
      giscusScript.setAttribute('data-strict', '0');
      giscusScript.setAttribute('data-reactions-enabled', '1');
      giscusScript.setAttribute('data-emit-metadata', '1');
      giscusScript.setAttribute('data-input-position', 'bottom');
      giscusScript.setAttribute('data-theme', 'noborder_dark');
      giscusScript.setAttribute('data-lang', 'en');
      giscusScript.setAttribute('data-loading', 'lazy');
      giscusScript.setAttribute('crossorigin', 'anonymous');
      giscusScript.async = true;
      
      // Добавляем скрипт в контейнер
      commentsContainer.appendChild(giscusScript);
      
      // Устанавливаем текущую версию и статус загрузки
      currentCommentVersion = version;
      giscusLoaded = false;
      
      // Открываем модальное окно только после всех подготовительных действий
      openModal();
    }

    // Глобальный кэш для количества комментариев по версиям
    const commentCountCache = {};
    let commentCountsLoaded = false;
    let lastCommentCountUpdate = 0;
    const MIN_UPDATE_INTERVAL = 10000; // Минимальный интервал между обновлениями (10 секунд)

    // Функция для загрузки количества комментариев для всех версий
    async function loadAllCommentCounts() {
      try {
        // Если счетчики уже загружены, не запрашиваем их снова
        if (commentCountsLoaded) return commentCountCache;
        
        // Проверяем, не слишком ли часто делаем запросы
        const now = Date.now();
        if (now - lastCommentCountUpdate < MIN_UPDATE_INTERVAL) {
          return commentCountCache;
        }
        
        lastCommentCountUpdate = now;

        const apiUrl = 'https://api.github.com/repos/LoaderSpot/table/discussions?per_page=100';
        const response = await fetch(apiUrl, {
          headers: {
            'Accept': 'application/vnd.github.v3+json'
          },
          cache: 'no-store' // Не кэшировать запрос
        });

        if (!response.ok) {
          throw new Error(`GitHub API error: ${response.status}`);
        }

        const discussions = await response.json();

        // Обрабатываем только те дискуссии, у которых название начинается с spotify-version
        discussions.forEach(discussion => {
          if (discussion.title.startsWith('spotify-version-')) {
            // Извлекаем версию из названия дискуссии (убираем префикс spotify-version-)
            const version = discussion.title.replace('spotify-version-', '');
            commentCountCache[version] = discussion.comments;
          }
        });

        commentCountsLoaded = true;

        // После загрузки обновляем все существующие кнопки комментариев
        updateExistingCommentButtons();

        return commentCountCache;
      } catch (error) {
        console.error('Error loading comment counts:', error);
        commentCountsLoaded = true; // Помечаем как загруженные, чтобы избежать повторных попыток
        return {};
      }
    }

    // Загружаем данные о комментариях при инициализации приложения
    document.addEventListener('DOMContentLoaded', () => {
      loadAllCommentCounts();
      
      // Настраиваем периодическое обновление счетчиков комментариев
      // Обновляем каждые 5 минут (300000 мс)
      setInterval(refreshAllCommentCounts, 300000);
      
      // Обновляем счетчики комментариев при возвращении на страницу
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          refreshAllCommentCounts();
        }
      });
    });

    // Функция для обновления всех счетчиков комментариев
    async function refreshAllCommentCounts() {
      try {
        // Проверяем, не слишком ли часто делаем запросы
        const now = Date.now();
        if (now - lastCommentCountUpdate < MIN_UPDATE_INTERVAL) {
          return commentCountCache;
        }
        
        lastCommentCountUpdate = now;

        const apiUrl = 'https://api.github.com/repos/LoaderSpot/table/discussions?per_page=100';
        const response = await fetch(apiUrl, {
          headers: {
            'Accept': 'application/vnd.github.v3+json'
          },
          cache: 'no-store' // Не кэшировать запрос
        });

        if (!response.ok) {
          throw new Error(`GitHub API error: ${response.status}`);
        }

        const discussions = await response.json();

        // Обрабатываем только те дискуссии, у которых название начинается с spotify-version
        discussions.forEach(discussion => {
          if (discussion.title.startsWith('spotify-version-')) {
            // Извлекаем версию из названия дискуссии (убираем префикс spotify-version-)
            const version = discussion.title.replace('spotify-version-', '');
            const newCount = discussion.comments;
            
            // Обновляем кэш только если значение изменилось
            if (commentCountCache[version] !== newCount) {
              commentCountCache[version] = newCount;
              updateCommentCountForVersion(version, newCount);
            }
          }
        });

        return commentCountCache;
      } catch (error) {
        console.error('Error refreshing all comment counts:', error);
        return commentCountCache;
      }
    }

    // Функция для принудительного обновления счетчика комментариев для конкретной версии
    async function refreshCommentCountForVersion(version) {
      try {
        // Проверяем, не слишком ли часто делаем запросы
        const now = Date.now();
        if (now - lastCommentCountUpdate < MIN_UPDATE_INTERVAL) {
          return;
        }
        
        lastCommentCountUpdate = now;

        const apiUrl = `https://api.github.com/repos/LoaderSpot/table/discussions?per_page=100`;
        const response = await fetch(apiUrl, {
          headers: {
            'Accept': 'application/vnd.github.v3+json'
          },
          cache: 'no-store' // Не кэшировать запрос
        });

        if (!response.ok) {
          throw new Error(`GitHub API error: ${response.status}`);
        }

        const discussions = await response.json();
        
        // Ищем дискуссию для конкретной версии
        const discussionTitle = `spotify-version-${version}`;
        const discussion = discussions.find(d => d.title === discussionTitle);
        
        if (discussion) {
          const newCount = discussion.comments;
          
          // Обновляем кэш только если значение изменилось
          if (commentCountCache[version] !== newCount) {
            commentCountCache[version] = newCount;
            
            // Обновляем счетчик на главной странице
            updateCommentCountForVersion(version, newCount);
          }
        }
      } catch (error) {
        console.error('Error refreshing comment count:', error);
      }
    }

    // Функция для обновления существующих кнопок комментариев после загрузки данных
    function updateExistingCommentButtons() {
      document.querySelectorAll('.comment-button').forEach(button => {
        const version = button.dataset.version;
        if (version && commentCountCache[version]) {
          const countBadge = button.querySelector('.comment-count') || document.createElement('span');
          if (!button.querySelector('.comment-count')) {
            countBadge.className = 'comment-count';
            button.appendChild(countBadge);
          }
          countBadge.textContent = commentCountCache[version];

          // Если есть комментарии, делаем бейдж более заметным
          if (commentCountCache[version] > 0) {
            button.classList.add('has-comments');
          }
        }
      });
    }

    // Функция для обновления счетчика комментариев для конкретной версии
    function updateCommentCountForVersion(version, count) {
      // Находим все кнопки комментариев для данной версии
      document.querySelectorAll(`.comment-button[data-version="${version}"]`).forEach(button => {
        // Обновляем счетчик
        const countBadge = button.querySelector('.comment-count') || document.createElement('span');
        if (!button.querySelector('.comment-count')) {
          countBadge.className = 'comment-count';
          button.appendChild(countBadge);
        }
        
        countBadge.textContent = count;
        
        // Обновляем стиль кнопки в зависимости от наличия комментариев
        if (count > 0) {
          button.classList.add('has-comments');
        } else {
          button.classList.remove('has-comments');
        }
      });
    }

    // Функция для создания кнопки комментариев с отображением количества
    function createCommentButton(version) {
      const commentButton = document.createElement('button');
      commentButton.className = 'comment-button';
      commentButton.dataset.version = version;
      commentButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`;
      commentButton.title = `Comments for version ${version}`;

      // Если данные о комментариях уже загружены, добавляем счетчик
      if (commentCountCache[version]) {
        const countBadge = document.createElement('span');
        countBadge.className = 'comment-count';
        countBadge.textContent = commentCountCache[version];
        commentButton.appendChild(countBadge);

        // Если есть комментарии, делаем бейдж более заметным
        if (commentCountCache[version] > 0) {
          commentButton.classList.add('has-comments');
        }
      }

      commentButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openComments(version);
      });

      return commentButton;
    }

    // Функция создания строк версии с добавлением кнопки комментариев
    const originalCreateVersionRows = createVersionRows;
    createVersionRows = function (versionKey, data, searchTerm = '') {
      const rows = originalCreateVersionRows(versionKey, data, searchTerm);
      if (rows.length > 0) {
        // Находим ячейку с версией (первая ячейка в первой строке)
        const versionCell = rows[0].querySelector('.version-cell');
        if (versionCell) {
          // Находим элемент с короткой версией
          const shortVersionElem = versionCell.querySelector('.short-version');
          if (shortVersionElem) {
            // Добавляем кнопку комментариев сразу после короткой версии
            const commentBtn = createCommentButton(versionKey);
            shortVersionElem.after(commentBtn); // Добавляем сразу после короткой версии
          }
        }
      }
      return rows;
    };

    const originalLoadMoreLinuxRows = loadMoreLinuxRows;
    loadMoreLinuxRows = function () {
      originalLoadMoreLinuxRows();

      // После загрузки строк находим все ячейки с версиями и добавляем кнопки комментариев
      const versionCells = document.querySelectorAll('.version-cell:not(.has-comments)');
      versionCells.forEach(cell => {
        const shortVersionElem = cell.querySelector('.version-text .short-version');
        if (shortVersionElem) {
          const version = shortVersionElem.textContent.trim();
          const commentBtn = createCommentButton(version);
          shortVersionElem.after(commentBtn); // Добавляем сразу после короткой версии
          cell.classList.add('has-comments'); // Помечаем, чтобы не добавлять кнопку снова
        }
      });
    };
  </script>

</html>
